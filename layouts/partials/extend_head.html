<!-- Scroll Animation Enhancement with Theme Toggle -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // === THEME TOGGLE LOGIC ===
  // Get saved theme preference or use system preference
  let savedTheme = localStorage.getItem('pref-theme');

  if (!savedTheme) {
    // Check system preference
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
      savedTheme = 'light';
    } else {
      savedTheme = 'dark'; // default to dark
    }
  }

  // Set initial theme
  if (savedTheme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
  } else {
    document.documentElement.removeAttribute('data-theme');
  }

  // Hook into theme toggle button
  const themeToggleBtn = document.getElementById('theme-toggle');
  if (themeToggleBtn) {
    themeToggleBtn.addEventListener('click', function(e) {
      e.preventDefault();

      // Get current theme
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const isLightMode = currentTheme === 'light';
      const nextTheme = isLightMode ? 'dark' : 'light';

      // Apply new theme
      if (nextTheme === 'light') {
        document.documentElement.setAttribute('data-theme', 'light');
      } else {
        document.documentElement.removeAttribute('data-theme');
      }

      // Save preference
      localStorage.setItem('pref-theme', nextTheme);

      // Visual feedback - add brief pulse to button
      themeToggleBtn.style.opacity = '0.7';
      setTimeout(() => {
        themeToggleBtn.style.opacity = '1';
      }, 150);
    });
  }

  // === SCROLL ANIMATION LOGIC ===
  // Intersection Observer for scroll-triggered animations
  const observerOptions = {
    threshold: 0.1,
    rootMargin: '0px 0px -50px 0px'
  };

  const observer = new IntersectionObserver(function(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('fade-in-visible');
        // Optional: stop observing once element is visible
        observer.unobserve(entry.target);
      }
    });
  }, observerOptions);

  // Observe post entries and article elements
  document.querySelectorAll('.post-entry, article, .post-content > *').forEach(el => {
    if (!el.classList.contains('fade-in')) {
      el.classList.add('fade-in');
    }
    observer.observe(el);
  });

  // Smooth scroll to anchor links
  document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function(e) {
      const href = this.getAttribute('href');

      // Only prevent default for internal anchors (not empty or # alone)
      if (href !== '#' && href.length > 1) {
        e.preventDefault();
        const target = document.querySelector(href);

        if (target) {
          // Smooth scroll with offset for fixed header
          const headerHeight = document.querySelector('.header')?.offsetHeight || 0;
          const targetPosition = target.getBoundingClientRect().top + window.pageYOffset - headerHeight - 20;

          window.scrollTo({
            top: targetPosition,
            behavior: 'smooth'
          });

          // Update URL without causing scroll
          window.history.pushState(null, null, href);
        }
      }
    });
  });

  // Add visual feedback for current scroll position
  function updateActiveHeading() {
    const headings = document.querySelectorAll('h2[id], h3[id]');
    const scrollPosition = window.scrollY + 100;

    headings.forEach(heading => {
      if (heading.offsetTop <= scrollPosition) {
        // Could add active state styling here if needed
        heading.classList.add('in-view');
      } else {
        heading.classList.remove('in-view');
      }
    });
  }

  window.addEventListener('scroll', updateActiveHeading, { passive: true });

  // Parallax effect for hero section (optional)
  const pageHeader = document.querySelector('.page-header');
  if (pageHeader) {
    window.addEventListener('scroll', function() {
      const scrolled = window.pageYOffset;
      pageHeader.style.transform = 'translateY(' + scrolled * 0.5 + 'px)';
    }, { passive: true });
  }

  // Add loading state animation for slow connections
  window.addEventListener('load', function() {
    document.body.classList.add('loaded');
  });

  // Prevent layout shift while images load
  const images = document.querySelectorAll('img');
  images.forEach(img => {
    if (!img.complete) {
      img.addEventListener('load', function() {
        this.classList.add('loaded');
      });
    } else {
      img.classList.add('loaded');
    }
  });
});

// Detect reduced motion preference
if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
  document.documentElement.style.scrollBehavior = 'auto';
}
</script>

<!-- Fade-in styles for scroll animations -->
<style>
.fade-in {
  opacity: 0;
  transform: translateY(30px);
  transition: opacity 0.6s ease-out, transform 0.6s ease-out;
}

.fade-in-visible {
  opacity: 1;
  transform: translateY(0);
}

.in-view {
  color: var(--accent-bright);
}

/* Ensure images don't cause layout shifts */
img {
  display: block;
}

/* Smooth transitions during scroll */
html {
  scroll-padding-top: 80px;
}

/* Loading skeleton animation */
.loading {
  animation: skeleton-loading 1.5s infinite;
  background: linear-gradient(90deg, var(--entry) 25%, var(--border) 50%, var(--entry) 75%);
  background-size: 200% 100%;
}

@keyframes skeleton-loading {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}

/* Respect prefers-reduced-motion */
@media (prefers-reduced-motion: reduce) {
  .fade-in,
  * {
    transition: none !important;
    animation: none !important;
  }

  html {
    scroll-behavior: auto;
  }
}
</style>
